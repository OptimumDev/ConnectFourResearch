# ConnectFourResearch

Исследование игры [Connect Four](https://ru.wikipedia.org/wiki/%D0%A7%D0%B5%D1%82%D1%8B%D1%80%D0%B5_%D0%B2_%D1%80%D1%8F%D0%B4)

## Реализация

Для данного исследования мы написали свою реализацию игры "Connect four". Мы использовали максимально эффективное использование данных для минимазии скорости работы логики (чтобы проверять именно скорость работы алгоритмов, а не логики игры). Вот несколько основных приемов, которые мы использовали:
 - Поле хранится в виде 2 `ulong` полей: позиции фишек желтого игрока и позиции фишек красного игрока. Бит 1 означает наличие фишки, иначе - ее отсутствие. Такой подход позволяет перебрать все линии из длины `N` за практически константное время (при учете, что нет смысла проверять длину меньше 2 и больше 4) - Делается `N` битовых сдвигов с `&` операцией и далее идет подсчет количества установленых бит.
~~~
  6 13 20 27 34 41 48   55 62  <-  Дополнительный ряд для того, чтобы 
+---------------------+            не учитывать следующий столбец при битовом сдвиге
| 5 12 19 26 33 40 47 | 54 61      (всегда содержит 0)
| 4 11 18 25 32 39 46 | 53 60
| 3 10 17 24 31 38 45 | 52 59
| 2  9 16 23 30 37 44 | 51 58
| 1  8 15 22 29 36 43 | 50 57
| 0  7 14 21 28 35 42 | 49 56 63  
+---------------------+
~~~
 - Дополнительно используется массив с указателями, на верхнюю фишку в столбике, позволяет быстро определять место выставления фишки и возможность ее установления вообще.
 - Реализован хэш Зобриста и функция `Equals` (которая тоже очень быстрая за счет хранения поля в двух числовых переменных)
 
## Проверка реализации

На реализацию алгоритма написаны тесты
 - Они покрывают большее количество игровых случаев
 - Поверяют функции сравнения
 - Тестируют правильное завершение игры
 
Они позволили нам быть уверенными в реализации логики и сосредоточить внимание на алгоритмах

## Интерфейс
 
Мы сделали 2 логгера: для консоли и для записи в файл - кроме поля они логирую варинты ходов и счет для удобного дебага  
Реализовали универсальный `Controller` который принимает два `ISolver` и умеет симулировать игру  
Так же сделали консольный интерфейс для пользователя в виде реализации `ISolver`

## Алгоритмы

Мы реализовали различные вариации MiniMax алгоритма
 1. NegaMax
 2. MiniMax с Альфа-Бета отсечением и двумя дополнительными стратегиями:
    - Приоритет ходов
    - Кэширование
 
В каждом из них используется итеративная глубина поиска (для ограничения по времени) с ограничением ее максимального знчаения (удобно для тестов)

Так же мы написали простой Жадный алгоритм для автоматических тестов на скорость алгоритма

## Тесты

Главным показателем мы решили считать счет, набранный за 10 секунд игр против жадного алгоритма. При этом алгоритмам дается 100 мс на ход и максимальная глубина ограничивается 5. Счет вычисляется простой формулой: `100 * <количество побед> + <количество игр>`

Вот результаты такого теста:

| Solver | Games | Wins | Score |
| --- | --- | --- | --- |
| MiniMax with cache | 112567 | 112567 | 11369267 |
| MiniMax with sorting with cache | 100670 | 100670 | 10167670 |
| MiniMax | 75 | 75 | 7575 |
| MiniMax with sorting | 75 | 75 | 7575 |
| NegaMax | 31 | 31 | 3131 |

Оказалось, что Альфа-бета отсечение увеличивает скорость примерно в 2.5 раза, а приоритет ходов (sorting) не имеет смысла для такого "глупого" противника. При этом кэширование увеличивает скорость 1500 раз

-- Место для тестов со сравнением --
